#!/bin/bash

set -e

# Check for required tools
if ! command -v svu &> /dev/null; then
    echo "Error: svu is not installed" >&2
    echo "Install it with: go install github.com/caarlos0/svu@latest" >&2
    exit 1
fi

if ! command -v goreleaser &> /dev/null; then
    echo "Error: goreleaser is not installed" >&2
    echo "Install it with: go install github.com/goreleaser/goreleaser@latest" >&2
    exit 1
fi

# Load Gitea credentials from tea config
TEA_CONFIG="$HOME/.config/tea/config.yml"
if [ -f "$TEA_CONFIG" ]; then
    # Try using yq for robust YAML parsing (if available)
    if command -v yq &> /dev/null; then
        GITEA_TOKEN=$(yq eval '.logins[0].token' "$TEA_CONFIG" 2>/dev/null)
        GITEA_USER=$(yq eval '.logins[0].user' "$TEA_CONFIG" 2>/dev/null)
    fi
    
    # Fallback to grep/awk if yq is not available or failed
    if [ -z "$GITEA_TOKEN" ] || [ "$GITEA_TOKEN" = "null" ]; then
        GITEA_TOKEN=$(grep -A 15 "^logins:" "$TEA_CONFIG" | grep "^\s*token:" | head -1 | awk '{print $2}')
    fi
    if [ -z "$GITEA_USER" ] || [ "$GITEA_USER" = "null" ]; then
        GITEA_USER=$(grep -A 15 "^logins:" "$TEA_CONFIG" | grep "^\s*user:" | head -1 | awk '{print $2}')
    fi
    
    # Export credentials if found
    if [ -n "$GITEA_TOKEN" ] && [ "$GITEA_TOKEN" != "null" ]; then
        export GITEA_TOKEN="$GITEA_TOKEN"
        export UPLOAD_GITEA_RPM_SECRET="$GITEA_TOKEN"
        echo "✓ Loaded Gitea token from $TEA_CONFIG"
    else
        echo "Warning: Could not extract token from $TEA_CONFIG" >&2
    fi
    
    if [ -n "$GITEA_USER" ] && [ "$GITEA_USER" != "null" ]; then
        export UPLOAD_GITEA_RPM_USERNAME="$GITEA_USER"
        echo "✓ Loaded Gitea username: $GITEA_USER"
    else
        echo "Warning: Could not extract username from $TEA_CONFIG" >&2
    fi
else
    echo "Warning: Tea config not found at $TEA_CONFIG" >&2
fi

# Parse arguments
VERSION_TYPE="${1:-snapshot}"

# Handle snapshot mode
if [ "$VERSION_TYPE" == "snapshot" ]; then
    echo "Running goreleaser in snapshot mode..."
    goreleaser release --snapshot --clean --skip=publish
    exit 0
fi

# Validate version type
case "$VERSION_TYPE" in
    next|major|minor|patch)
        ;;
    *)
        echo "Error: Invalid version type '$VERSION_TYPE'" >&2
        echo "Usage: $0 [next|major|minor|patch|snapshot]" >&2
        echo "  next    - Use svu next (default)" >&2
        echo "  major   - Use svu major" >&2
        echo "  minor   - Use svu minor" >&2
        echo "  patch   - Use svu patch" >&2
        echo "  snapshot - Run goreleaser in snapshot mode (skip tagging)" >&2
        exit 1
        ;;
esac

# Get the next version tag
TAG=$(svu "$VERSION_TYPE")

if [ -z "$TAG" ]; then
    echo "Error: Failed to get version tag" >&2
    exit 1
fi

echo "Version: $TAG"
echo "Creating tag: $TAG"
git tag -a "$TAG" -m "Release $TAG"

echo "Pushing tag: $TAG"
git push origin "$TAG"

echo "Running goreleaser..."
goreleaser release --clean